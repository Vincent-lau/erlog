-module(worker).

-export([start_link/0, start/0, start/1, start_link/1, start_working/0, stop/0]).
-export([init/1, handle_cast/2, handle_call/3, terminate/2]).

-include("../include/task_repr.hrl").

-include_lib("kernel/include/logger.hrl").

-define(coor_node, 'coor@127.0.0.1').
-define(SLEEP_TIME, 300).

-behaviour(gen_server).

-type working_mode() :: success | failure | straggle.
-type worker_spec() :: success | {failure, float()} | {straggle, float()}.

-export_type([worker_spec/0]).

-record(worker_state,
        {coor_pid :: pid(),
         num_tasks :: integer(),
         task_num :: integer(),
         stage_num :: integer(),
         mode :: working_mode()}).

name() ->
  worker.

%%% Client callbacks

start() ->
  start(success).

start_link() ->
  start_link(success).

start(Mode) ->
  gen_server:start({local, name()}, ?MODULE, [Mode], []).

start_link(Mode) ->
  gen_server:start_link({local, name()}, ?MODULE, [Mode], []).

start_working() ->
  gen_server:cast(name(), work).

stop() ->
  gen_server:call(name(), terminate).

%%% Server functions

init([Mode]) ->
  true = net_kernel:connect_node(?coor_node),
  global:sync(), % make sure that worker sees the registered name
  CoorPid = global:whereis_name(coor),
  erpc:cast(?coor_node, coordinator, reg_worker, [node()]),
  NumTasks = erpc:call(?coor_node, coordinator, get_num_tasks, []),
  spawn(fun check_coor/0),
  {ok,
   #worker_state{coor_pid = CoorPid,
                 num_tasks = NumTasks,
                 task_num = 0,
                 stage_num = 0,
                 mode = Mode}}.

handle_call(terminate, _From, State) ->
  {stop, normal, ok, State}.

handle_cast(work, State = #worker_state{mode = Mode}) ->
  case Mode of
    failure ->
      spawn_link(fun abnormal_worker:crasher/0);
    _Other ->
      ok
  end,
  % TODO better use a supervisor approach
  spawn(fun() -> work(State) end),
  {noreply, State}.

terminate(normal, _State) ->
  net_kernel:stop(),
  init:stop();
terminate(coor_down, State) ->
  io:format("coordinator is down, terminate as well~n"),
  terminate(normal, State).

%%% Private functions

work(State =
       #worker_state{mode = Mode}) ->
  try erpc:call(?coor_node, coordinator, assign_task, [node()], 5000) of
    T = #task{type = evaluate,
              task_num = TaskNum,
              stage_num = StageNum,
              delta_db = DeltaDB,
              prog = Program} ->
      ?LOG_INFO(#{worker_node => node(), worker_state => State}),
      ?LOG_INFO(#{worker_node => node(),
                  task_num => TaskNum,
                  stage_num => StageNum}),


      FullDB = call_coor(get_full_db, []),

      % we need the old delta db because we might want the delta db generated from
      % other workers
      OldDeltaDB = call_coor(get_delta_db, []),

      case Mode of
        straggle ->
          abnormal_worker:straggler();
        _ ->
          ok
      end,
      % we need to take the diff between this delta and the FullDB because our delta
      % might be generated by other workers
       
      % use imm_conseq/3
      % need to store FullDB somewhere for later stages of evaluation
      % and this is not a static state, it changes every iteration
      % and is potentially huge, so this cost might be quite large
      {NewFullDB, NewDeltaDB} =
        eval:eval_seminaive_one(Program, dbs:union(FullDB, OldDeltaDB), DeltaDB),
      lager:debug("new_db ~p~n", [dbs:to_string(NewDeltaDB)]),
      % hash the new DB locally and write to disk
      % with only tuples that have not been generated before
      finish_task(T, {NewFullDB, NewDeltaDB}),
      lager:debug("~p rpc results for finish at stage ~p task ~p",
                [node(), StageNum, TaskNum]),
      % request new tasks
      lager:debug("~p stage-~w task-~w finished, requesting new task",
                [node(), StageNum, TaskNum]),
      NewState = State#worker_state{task_num = TaskNum, stage_num = StageNum},
      lager:debug("worker_node ~p, new_state ~p", [node(), NewState]),
      work(NewState);
    #task{type = wait} ->
      lager:debug("~p this is a wait task, sleeping for ~p sec~n", [node(), ?SLEEP_TIME / 1000]),
      timer:sleep(?SLEEP_TIME),
      work(State);
    #task{type = terminate} ->
      lager:debug("~p all done, time to relax~n", [node()]);
    Other ->
      lager:info("~p some other stuff ~p~n", [node(), Other])
  catch
    error:{erpc, timeout} -> % let's try again
      lager:info("~p rpc timed out, trying again~n", [node()]),
      work(State);
    exit:{exception, Reason} -> % exception from the gen_server side
      lager:info("~p gen_server call timed out with reason ~p, trying again~n",
                [node(), Reason]),
      work(State)
  end.

%%% Private functions


call_coor(Function, Args) ->
  try erpc:call(?coor_node, coordinator, Function, Args, 5000) of
    Reply ->
      Reply
  catch
    error:{erpc, timeout} ->
      lager:info("~p finish task timeout, trying again~n", [node()]),
      call_coor(Function, Args);
    exit:{exception, Reason} ->
      lager:info("~p, gen_server call coordinator side exception ~p, trying again", [node(), Reason]),
      call_coor(Function, Args)
  end.


-spec finish_task(mr_task(), {dl_db_instance(), dl_db_instance()}) -> ok.
finish_task(Task, {NewFullDB, NewDeltaDB}) ->
  call_coor(finish_task, [Task, node(), {NewFullDB, NewDeltaDB}]).


% TODO is this worker's responsability or its supervisor's responsibility
% we need to terminate top down from the supervisor of this worker
% the better way is to ask a higher level supervisor to see that the coordinator
% has died and hence stop worker_sup
% but for now just do this
check_coor() ->
  ok = net_kernel:monitor_nodes(true),
  receive
    {nodedown, ?coor_node} ->
      stop()
  end.
