-module(worker).

-export([start_link/0, start/0, start/1, start_link/1, start_working/0, stop/0]).
-export([init/1, handle_cast/2, handle_call/3, terminate/2]).

-include("../include/task_repr.hrl").


-define(coor_node, 'coor@host.com').
-define(SLEEP_TIME, 300).

-behaviour(gen_server).

-type working_mode() :: success | failure | straggle.
-type worker_spec() :: success | {failure, float()} | {straggle, float()}.

-export_type([worker_spec/0]).

-record(worker_state,
        {coor_pid :: pid(),
         num_tasks :: integer(),
         task_num :: integer(),
         stage_num :: integer(),
         full_db :: dl_db_instance(),
         mode :: working_mode()}).

name() ->
  worker.

%%% Client callbacks

start() ->
  start(success).

start_link() ->
  start_link(success).

start(Mode) ->
  gen_server:start({local, name()}, ?MODULE, [Mode], []).

start_link(Mode) ->
  gen_server:start_link({local, name()}, ?MODULE, [Mode], []).

start_working() ->
  gen_server:cast(name(), work).

stop() ->
  gen_server:call(name(), terminate).

%%% Server functions

init([Mode]) ->
  ok = attempt_connect_coor(),
  CoorPid = global:whereis_name(coor),
  erpc:cast(?coor_node, coordinator, reg_worker, [node()]),
  NumTasks = call_coor(get_num_tasks, []),
  spawn(fun check_coor/0),
  {ok,
   #worker_state{coor_pid = CoorPid,
                 num_tasks = NumTasks,
                 full_db = dbs:new(),
                 task_num = 0,
                 stage_num = 0,
                 mode = Mode}}.

handle_call(terminate, _From, State) ->
  {stop, normal, ok, State}.

handle_cast(work, State = #worker_state{mode = Mode}) ->
  case Mode of
    failure ->
      spawn_link(fun abnormal_worker:crasher/0);
    _Other ->
      ok
  end,
  % TODO better use a supervisor approach
  spawn(fun() -> work(State) end),
  {noreply, State}.

terminate(normal, _State) ->
  net_kernel:stop(),
  init:stop();
terminate(coor_down, State) ->
  io:format("coordinator is down, terminate as well~n"),
  terminate(normal, State).

%%% Private functions

work(State =
       #worker_state{stage_num = CurStageNum,
                     full_db = FullDB,
                     mode = Mode}) ->
  case call_coor(assign_task, [node()]) of
    T = #task{type = evaluate,
              task_num = TaskNum,
              stage_num = TaskStageNum,
              delta_db = DeltaDB,
              prog = Program} ->
      CurFullDB =
        case TaskStageNum =/= CurStageNum of
          true ->
            FullDB2 = call_coor(get_full_db, []),
            OldDeltaDB = call_coor(get_delta_db, []),
            dbs:union(FullDB2, OldDeltaDB);
          false ->
            FullDB
        end,

      % we need the old delta db because we might want the delta db generated from
      % other workers
      case Mode of
        straggle ->
          abnormal_worker:straggler();
        _ ->
          ok
      end,
      % we need to take the diff between this delta and the FullDB because our delta
      % might be generated by other workers
      % use imm_conseq/3
      % need to store FullDB somewhere for later stages of evaluation
      % and this is not a static state, it changes every iteration
      % and is potentially huge, so this cost might be quite large
      {NewFullDB, NewDeltaDB} = eval:eval_seminaive_one(Program, CurFullDB, DeltaDB),
      lager:debug("new_db ~p~n", [dbs:to_string(NewDeltaDB)]),
      % hash the new DB locally and write to disk
      % with only tuples that have not been generated before
      finish_task(T, {NewFullDB, NewDeltaDB}),
      lager:debug("~p rpc results for finish at stage ~p task ~p", [node(), TaskStageNum, TaskNum]),
      % request new tasks
      lager:debug("~p stage-~w task-~w finished, requesting new task",
                  [node(), TaskStageNum, TaskNum]),
      NewState = State#worker_state{task_num = TaskNum, stage_num = TaskStageNum, full_db = CurFullDB},
      lager:debug("worker_node ~p, new_state ~p", [node(), NewState]),
      work(NewState);
    #task{type = wait} ->
      lager:debug("~p this is a wait task, sleeping for ~p sec~n",
                  [node(), ?SLEEP_TIME / 1000]),
      timer:sleep(?SLEEP_TIME),
      work(State);
    #task{type = terminate} ->
      lager:debug("~p all done, time to relax~n", [node()]);
    Other ->
      lager:info("~p some other stuff ~p~n", [node(), Other])
  end.

%%% Private functions


call_coor(Function, Args) ->
  call_coor(Function, Args, 1000).

call_coor(Function, Args, Timeout) ->
  try erpc:call(?coor_node, coordinator, Function, Args, 5000) of
    Reply ->
      lager:debug("~p function call ~p succeed", [node(), Function]),
      Reply
  catch
    error:{erpc, timeout} ->
      lager:debug("~p function ~p task timeout, trying again~n", [node(), Function]),
      timer:sleep(Timeout + rand:uniform(2000)),
      call_coor(Function, Args, Timeout * 2);
    exit:{exception, Reason} ->
      lager:debug("~p, gen_server call coordinator side exception ~p, trying again",
                  [node(), Reason]),
      timer:sleep(Timeout + rand:uniform(2000)),
      call_coor(Function, Args, Timeout * 2)
  end.

-spec finish_task(mr_task(), {dl_db_instance(), dl_db_instance()}) -> ok.
finish_task(Task, {NewFullDB, NewDeltaDB}) ->
  call_coor(finish_task, [Task, node(), {NewFullDB, NewDeltaDB}]).

% TODO is this worker's responsability or its supervisor's responsibility
% we need to terminate top down from the supervisor of this worker
% the better way is to ask a higher level supervisor to see that the coordinator
% has died and hence stop worker_sup
% but for now just do this
check_coor() ->
  ok = net_kernel:monitor_nodes(true),
  receive
    {nodedown, ?coor_node} ->
      stop()
  end.

attempt_connect_coor() ->
  case net_adm:ping(?coor_node) of
    pang ->
      timer:sleep(2000),
      attempt_connect_coor();
    pong -> 
      global:sync(),
      case global:whereis_name(coor) of
        undefined ->
          timer:sleep(2000),
          attempt_connect_coor();
        _Pid ->
          ok
      end
  end.